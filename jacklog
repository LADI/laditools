#!/usr/bin/env python

# pyjackctl - The python jackdbus controller suite
# jackctl_logview - A log viewer for the python JACK dbus suite
# Copyright (C) 2007-2008, Marc-Olivier Barre and Nedko Arnaudov.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import pygtk
pygtk.require ('2.0')
import gtk
import gtk.glade
import pyjackctl
from gobject import timeout_add
from os import environ, sep, path
import sys

try:
  import vte
except:
  error = gtk.MessageDialog (None, gtk.DIALOG_MODAL, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, 'You need to install python bindings for libvte')
  error.run ()
  exit (1)

# Default configuration
jackdbus_log_default = environ['HOME'] + sep + ".log" + sep + "jack" + sep + "jackdbus.log"
max_lines_default = 100

class jacklog (gtk.glade.XML):
    def __init__ (self, logfile = None, title = None):
        # Handle the configuration
        self.jacklog_config = pyjackctl.config ()
        self.param_dict = self.jacklog_config.get_as_dict ('jacklog')
        if 'jackdbus_log' not in self.param_dict:
            self.param_dict['jackdbus_log'] = jackdbus_log_default, {}
        if 'max_lines' not in self.param_dict:
            self.param_dict['max_lines'] = max_lines_default, {}
        self.jackdbus_log, devnull = self.param_dict['jackdbus_log']
        if logfile:
            self.jackdbus_log = logfile
        max_lines_text, devnull = self.param_dict['max_lines']
        self.max_lines = int (max_lines_text)
        # Load the glade file
        gtk.glade.XML.__init__ (self, "/usr/share/pyjackctl/data/ladilog_ui.glade")
        # Get the ui ready for action
        self.event_dict = {"on_jackctl_logview_ui_destroy" : self.on_quit,
            "on_close_button_clicked" : self.on_quit,
            "on_clear_button_clicked" : self.on_clear_text,
            "on_purge_button_clicked" : self.on_purge}
        self.signal_autoconnect (self.event_dict)
        # Create our terminal
        self.vte = vte.Terminal ()
        # TODO: I don't understand why I can't run tail instead of a login shell...
        # self.vte.fork_command ("/usr/bin/tail", ["-"+str (self.max_lines)+"f ", self.jackdbus_log])
        self.vte.fork_command ();
        self.vte.feed_child ('tail -' + str (self.max_lines) + 'f ' + self.jackdbus_log + '\n')
        self.vte.show ()
        self.logview_vbox = self.get_widget ("logview_vbox")
        self.button_hbox = self.get_widget ("button_hbox")
        self.laditools_logo = self.get_widget ("laditools_logo")
        self.logview_vbox.pack_start (self.vte)
        self.logview_vbox.reorder_child (self.laditools_logo, 0)
        self.logview_vbox.reorder_child (self.vte, 1)
        self.logview_vbox.reorder_child (self.button_hbox, 2)
        if title:
            self.get_widget ("ladilog_ui").set_title(title)

    def on_quit (self, data=None):
        gtk.main_quit ()

    def on_clear_text (self, data=None):
        self.text_buffer.set_text ("")

    def on_purge (self, date=None):
        # Opens the file in write anew mode thus clearing the file and close it right away 
        open (self.jackdbus_log, "w+")
        self.text_buffer.set_text ("")

    def update (self):
        # Append latest output to the buffer
        line = self.log_file.readline ()
        while line:
            self.text_buffer.insert(self.text_buffer.get_end_iter (), line)
            line = self.log_file.readline ()
        self.log_file.seek (self.log_file.tell ())
        return True

    def on_resize (self, data = None):
        # Scrolldown
        self.text_buffer.move_mark (self.current_pos, self.text_buffer.get_end_iter ())
        self.log_textview.scroll_mark_onscreen (self.current_pos)

    def on_text_change (self, data = None):
        # Scrolldown
        self.text_buffer.move_mark (self.current_pos, self.text_buffer.get_end_iter ())
        self.log_textview.scroll_mark_onscreen (self.current_pos)
        # Cleanup the buffer
        line_count = self.text_buffer.get_line_count ()
        if line_count > self.max_lines:
            self.text_buffer.delete (self.text_buffer.get_start_iter (), self.text_buffer.get_iter_at_line (line_count-self.max_lines))

    def run (self):
        gtk.main ()
        self.jacklog_config.set_as_dict ('jacklog', self.param_dict)
        return 0

logfile = None
title = None

execname = path.basename (sys.argv[0])

if execname == 'lashlog':
    logfile = environ['HOME'] + sep + ".log" + sep + "lash" + sep + "lash.log"
    title = 'LASH log'

jacklog (logfile, title).run ()

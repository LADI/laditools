#!/usr/bin/env python

# LADITools - Linux Audio Desktop Integration Tools
# ladiconf - A configuration GUI for your Linux Audio Desktop
# Copyright (C) 2007-2008, Marc-Olivier Barre and Nedko Arnaudov.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import pygtk
pygtk.require ('2.0')
import gtk
import gtk.glade
import laditools

class ladiconf (gtk.glade.XML):
    def __init__ (self):
        # Dbus interface
        self.jack = laditools.jack_configure ()
        # Load the glade file
        gtk.glade.XML.__init__ (self, "/usr/share/laditools/data/ladiconf_ui.glade")
        # Get the ui ready for action
        self.event_dict = {"on_ladiconf_ui_destroy" : self.on_quit,
            "on_close_button_clicked" : self.on_quit,
            "on_apply_button_clicked" : self.on_apply}
        self.signal_autoconnect (self.event_dict)
        self.engine_param_dict = {}
        self.driver_param_dict = {}
        self.changed_engine_params = []
        self.changed_driver_params = []
        self.apply_button = self.get_widget ("apply_button")
        # Driver tab setup
        self.driver_vbox_left = self.get_widget ("driver_vbox_left")
        self.driver_vbox_right = self.get_widget ("driver_vbox_right")
        self.driver_params = self.jack.get_driver_param_names ()
        for driver_param in self.driver_params:
            typestr = self.jack.get_driver_param_type(driver_param)
            isset, default, value = self.jack.get_driver_param_value (driver_param)
            short_descr = self.jack.get_driver_short_description (driver_param)
            if typestr == "b":
                self.driver_vbox_left.pack_start (self.make_checkbox (driver_param, value, short_descr, self.driver_param_dict), False)
            elif typestr == "s":
                self.driver_vbox_right.pack_start (self.make_textentry (driver_param, value, short_descr, self.driver_param_dict), False)
            elif typestr == "u" or typestr == "i":
                self.driver_vbox_right.pack_start (self.make_spinbutton (driver_param, value, short_descr, self.driver_param_dict), False)
        #Engine tab setup
        self.engine_vbox_left = self.get_widget ("engine_vbox_left")
        self.engine_vbox_right = self.get_widget ("engine_vbox_right")
        self.engine_params = self.jack.get_engine_param_names ()
        for engine_param in self.engine_params:
            typestr = self.jack.get_engine_param_type (engine_param)
            isset, default, value = self.jack.get_engine_param_value (engine_param)
            short_descr = self.jack.get_engine_short_description (engine_param)
            if typestr == "b":
                self.engine_vbox_left.pack_start (self.make_checkbox(engine_param, value, short_descr, self.engine_param_dict), False)
            elif typestr == "s":
                self.engine_vbox_right.pack_start (self.make_textentry(engine_param, value, short_descr, self.engine_param_dict), False)
            elif typestr == "u" or typestr == "i":
                self.engine_vbox_right.pack_start (self.make_spinbutton(engine_param, value, short_descr, self.engine_param_dict), False)
    
    def make_checkbox (self, param_name, value, short_descr, storage_dict):
        storage_dict[param_name] = gtk.CheckButton (param_name)
        storage_dict[param_name].set_active (value)
        storage_dict[param_name].set_tooltip_text (short_descr)
        storage_dict[param_name].connect ("toggled", self.on_param_update, param_name)
        storage_dict[param_name].show ()
        return storage_dict[param_name]
    
    def make_spinbutton (self, param_name, value, short_descr, storage_dict):
        storage_dict[param_name] = gtk.SpinButton ()
        storage_dict[param_name].set_range (0, 100000)
        storage_dict[param_name].set_increments (1, 1000)
        storage_dict[param_name].set_value (value)
        storage_dict[param_name].set_tooltip_text (short_descr)
        param_label = gtk.Label (param_name)
        param_label.set_alignment (1, 0.5)
        param_label.set_padding (10, 0)
        param_widget = gtk.HBox ()
        param_widget.set_homogeneous (True)
        param_widget.pack_start (param_label)
        param_widget.pack_start (storage_dict[param_name])
        storage_dict[param_name].connect ("changed", self.on_param_update, param_name)
        param_widget.show_all ()
        return param_widget

    def make_textentry (self, param_name, value, short_descr, storage_dict):
        storage_dict[param_name] = gtk.Entry ()
        storage_dict[param_name].set_text (value)
        storage_dict[param_name].set_tooltip_text (short_descr)
        param_label = gtk.Label (param_name)
        param_label.set_alignment (1, 0.5)
        param_label.set_padding (10, 0)
        param_widget = gtk.HBox ()
        param_widget.set_homogeneous (True)
        param_widget.pack_start (param_label)
        param_widget.pack_start (storage_dict[param_name])
        param_widget.show_all ()
        storage_dict[param_name].connect ("changed", self.on_param_update, param_name)
        return param_widget

    def on_param_update (self, widget, param_name):
        if param_name in self.driver_params and param_name not in self.changed_driver_params:
            self.changed_driver_params.append (param_name)
        if param_name in self.engine_params and param_name not in self.changed_engine_params:
            self.changed_engine_params.append (param_name)
        self.apply_button.set_sensitive (True)

    def on_apply(self, data=None):
        for changed_driver_param in self.changed_driver_params:
            widget_type = type (self.driver_param_dict[changed_driver_param])
            if widget_type is gtk.CheckButton:
                self.jack.set_driver_param_value (changed_driver_param, self.driver_param_dict[changed_driver_param].get_active ())
            elif widget_type is gtk.SpinButton:
                self.jack.set_driver_param_value (changed_driver_param, self.driver_param_dict[changed_driver_param].get_value ())
            elif widget_type is gtk.Entry:
                self.jack.set_driver_param_value (changed_driver_param, self.driver_param_dict[changed_driver_param].get_text ())
        for changed_engine_param in self.changed_engine_params:
            widget_type = type(self.engine_param_dict[changed_engine_param])
            if widget_type is gtk.CheckButton:
                self.jack.set_engine_param_value (changed_engine_param, self.engine_param_dict[changed_engine_param].get_active ())
            elif widget_type is gtk.SpinButton:
                self.jack.set_engine_param_value (changed_engine_param, self.engine_param_dict[changed_engine_param].get_value ())
            elif widget_type is gtk.Entry:
                self.jack.set_engine_param_value (changed_engine_param, self.engine_param_dict[changed_engine_param].get_text ())
        self.apply_button.set_sensitive (False)
        self.changed_engine_params = []
        self.changed_driver_params = []

    def on_quit (self, data=None):
        gtk.main_quit ()

    def run (self):
        gtk.main ()
        return 0

ladiconf ().run ()

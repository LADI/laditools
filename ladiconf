#!/usr/bin/env python

# LADITools - Linux Audio Desktop Integration Tools
# ladiconf - A configuration GUI for your Linux Audio Desktop
# Copyright (C) 2007-2008, Marc-Olivier Barre and Nedko Arnaudov.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import pygtk
pygtk.require ('2.0')
import gtk
import gtk.glade
import laditools

jack = laditools.jack_configure()

class parameter:
    def __init__(self, name, proxy):
        self.name = name
        self.proxy = proxy

    def get_name(self):
        return self.name

    def get_type(self):
        return self.proxy.get_type(self.name)

    def get_value(self):
        return self.proxy.get_value(self.name)

    def set_value(self, value):
        return self.proxy.set_value(self.name, value)

    def get_short_description(self):
        return self.proxy.get_short_description(self.name)

class parameters_proxy:
    def __init__(self, get_names_function):
        self.params = []
        param_names = get_names_function()
        for name in param_names:
            self.params.append(parameter(name, self))

    def __iter__(self):
        return iter(self.params)

    def get_type(self, name):
        pass

    def get_value(self, name):
        pass

    def set_value(self, name, value):
        pass

    def get_short_description(self, name):
        pass

class engine_parameters_proxy(parameters_proxy):
    def __init__(self):
        parameters_proxy.__init__(self, jack.get_engine_param_names)

    def get_type(self, name):
        return jack.get_engine_param_type(name)

    def get_value(self, name):
        return jack.get_engine_param_value(name)

    def set_value(self, name, value):
        jack.set_engine_param_value(name, value)

    def get_short_description(self, name):
        return jack.get_engine_short_description(name)

class driver_parameters_proxy(parameters_proxy):
    def __init__(self):
        parameters_proxy.__init__(self, jack.get_driver_param_names)

    def get_type(self, name):
        return jack.get_driver_param_type(name)

    def get_value(self, name):
        return jack.get_driver_param_value(name)

    def set_value(self, name, value):
        jack.set_driver_param_value(name, value)

    def get_short_description(self, name):
        return jack.get_driver_short_description(name)

class ladiconf (gtk.glade.XML):
    def __init__ (self):
        # Dbus interface
        # Load the glade file
        gtk.glade.XML.__init__ (self, "/usr/share/laditools/data/ladiconf_ui.glade")
        # Get the ui ready for action
        self.event_dict = {"on_ladiconf_ui_destroy" : self.on_quit,
            "on_close_button_clicked" : self.on_quit,
            "on_apply_button_clicked" : self.on_apply}
        self.signal_autoconnect (self.event_dict)
        self.apply_button = self.get_widget ("apply_button")

        # Engine tab setup
        vbox_left = self.get_widget("engine_vbox_left")
        vbox_right = self.get_widget("engine_vbox_right")
        self.engine_params = engine_parameters_proxy()
        self.fill_params(vbox_left, vbox_right, self.engine_params)

        # Driver tab setup
        vbox_left = self.get_widget("driver_vbox_left")
        vbox_right = self.get_widget("driver_vbox_right")
        self.driver_params = driver_parameters_proxy()
        self.fill_params(vbox_left, vbox_right, self.driver_params)

        #print self.run_driver_change_dialog()

    def fill_params(self, vbox_left, vbox_right, params):
        widget_map = {
            "b": [self.make_checkbox, vbox_left],
            "s": [self.make_textentry, vbox_right],
            "i": [self.make_spinbutton, vbox_right],
            "u": [self.make_spinbutton, vbox_right],
            "y": [self.make_textentry, vbox_right],
            }
        for param in params:
            if not widget_map.has_key(param.get_type()):
                continue
            mapping = widget_map[param.get_type()]
            make_function = mapping[0]
            container = mapping[1]
            widget = make_function(param)
            widget.show_all()
            param.modified = False
            container.pack_start(widget, False)
    
    def make_checkbox(self, param):
        widget = gtk.CheckButton(param.get_name())
        widget.set_active(param.get_value()[2])
        widget.set_tooltip_text(param.get_short_description())
        widget.connect("toggled", self.on_param_update, param)
        param.widget = widget
        return widget
    
    def make_spinbutton(self, param):
        widget = gtk.SpinButton ()
        widget.set_range(0, 100000)
        widget.set_increments(1, 1000)
        widget.set_value(param.get_value()[2])
        widget.set_tooltip_text(param.get_short_description())
        param_label = gtk.Label(param.get_name())
        param_label.set_alignment(1, 0.5)
        param_label.set_padding(10, 0)
        param_widget = gtk.HBox()
        param_widget.set_homogeneous(True)
        param_widget.pack_start(param_label)
        param_widget.pack_start(widget)
        widget.connect("changed", self.on_param_update, param)
        param.widget = widget
        return param_widget

    def make_textentry(self, param):
        widget = gtk.Entry()
        widget.set_text(str(param.get_value()[2]))
        widget.set_tooltip_text(param.get_short_description())
        param_label = gtk.Label(param.get_name())
        param_label.set_alignment(1, 0.5)
        param_label.set_padding(10, 0)
        param_widget = gtk.HBox()
        param_widget.set_homogeneous (True)
        param_widget.pack_start(param_label)
        param_widget.pack_start(widget)
        widget.connect("changed", self.on_param_update, param)
        param.widget = widget
        return param_widget

    def on_param_update(self, widget, param):
        param.modified = True
        self.apply_button.set_sensitive(True)

    def on_apply(self, data=None):
        for params in self.engine_params, self.driver_params:
            for param in params:
                if not param.modified:
                    continue
                widget_type = type(param.widget)
                if widget_type is gtk.CheckButton:
                    param.set_value(param.widget.get_active())
                elif widget_type is gtk.SpinButton:
                    param.set_value(param.widget.get_value())
                elif widget_type is gtk.Entry:
                    param.set_value(param.widget.get_text())
        self.apply_button.set_sensitive(False)

    def on_quit (self, data=None):
        gtk.main_quit ()

    def run (self):
        gtk.main ()
        return 0

    def run_driver_change_dialog(self):
        dlg = gtk.Dialog()
        dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
        dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK)

        driver_list = gtk.TreeView()
        dlg.vbox.pack_start(driver_list, True)

        store = gtk.ListStore(str)

        text_renderer = gtk.CellRendererText()

        column = gtk.TreeViewColumn("Name", text_renderer, text=0)
        driver_list.append_column(column)

        drivers = self.jack.get_available_driver()
        for driver in drivers:
            store.append([driver])

        driver_list.set_model(store)

        selection = driver_list.get_selection()

        current_driver = self.jack.get_selected_driver()
        if current_driver:
            for row in store:
                if current_driver == row[0]:
                    selection.select_iter(row.iter)

        driver_list.connect("row-activated", lambda *x: dlg.response(gtk.RESPONSE_OK))

        driver = None

        dlg.show_all()
        ret = dlg.run()
        if ret == gtk.RESPONSE_OK:
            driver = store.get(selection.get_selected()[1], 0)[0]
        dlg.hide()

        return driver

ladiconf ().run ()

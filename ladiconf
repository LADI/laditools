#!/usr/bin/env python

# LADITools - Linux Audio Desktop Integration Tools
# ladiconf - A configuration GUI for your Linux Audio Desktop
# Copyright (C) 2007-2008, Marc-Olivier Barre and Nedko Arnaudov.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import pygtk
pygtk.require ('2.0')
import gtk
import laditools
import gobject

jack = laditools.jack_configure()

class parameter:
    def __init__(self, name, proxy):
        self.name = name
        self.proxy = proxy

    def get_name(self):
        return self.name

    def get_type(self):
        return self.proxy.get_type(self.name)

    def get_value(self):
        return self.proxy.get_value(self.name)

    def set_value(self, value):
        return self.proxy.set_value(self.name, value)

    def get_short_description(self):
        return self.proxy.get_short_description(self.name)

    def has_range(self):
        return self.proxy.has_range(self.name)

    def has_enum(self):
        return self.proxy.has_enum(self.name)

    def is_strict_enum(self):
        return self.proxy.is_strict_enum(self.name)

    def is_fake_values_enum(self):
        return self.proxy.is_fake_values_enum(self.name)

    def get_enum_values(self):
        return self.proxy.get_enum_values(self.name)

class parameters_proxy:
    def __init__(self, get_names_function):
        self.params = []
        param_names = get_names_function()
        for name in param_names:
            self.params.append(parameter(name, self))

    def __iter__(self):
        return iter(self.params)

    def get_type(self, name):
        pass

    def get_value(self, name):
        pass

    def set_value(self, name, value):
        pass

    def get_short_description(self, name):
        pass

    def has_range(self, name):
        return False

    def has_enum(self, name):
        return False

    def is_strict_enum(self, name):
        return False

    def is_fake_values_enum(self, name):
        return False

    def get_enum_values(self, name):
        return []

class engine_parameters_proxy(parameters_proxy):
    def __init__(self):
        parameters_proxy.__init__(self, jack.get_engine_param_names)

    def get_type(self, name):
        return jack.get_engine_param_type(name)

    def get_value(self, name):
        return jack.get_engine_param_value(name)

    def set_value(self, name, value):
        jack.set_engine_param_value(name, value)

    def get_short_description(self, name):
        return jack.get_engine_short_description(name)

class driver_parameters_proxy(parameters_proxy):
    def __init__(self):
        parameters_proxy.__init__(self, jack.get_driver_param_names)

    def get_type(self, name):
        return jack.get_driver_param_type(name)

    def get_value(self, name):
        return jack.get_driver_param_value(name)

    def set_value(self, name, value):
        jack.set_driver_param_value(name, value)

    def get_short_description(self, name):
        return jack.get_driver_short_description(name)

    def has_range(self, name):
        return jack.driver_param_has_range(name)

    def has_enum(self, name):
        return jack.driver_param_has_enum(name)

    def is_strict_enum(self, name):
        return jack.driver_param_is_strict_enum(name)

    def is_fake_values_enum(self, name):
        return jack.driver_param_is_fake_value(name)

    def get_enum_values(self, name):
        return jack.driver_param_get_enum_values(name)

class configure_command:
    def __init__(self):
        pass

    def get_description(self):
        pass

    def get_window_title(self):
        return self.get_description();

    def run(self, arg):
        pass

class jack_driver_change_command(configure_command):
    def get_description(self):
        return 'Select JACK driver'

    def run(self, arg):
        dlg = gtk.Dialog()
        dlg.set_title(self.get_window_title())
        dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
        dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK)

        driver_list = gtk.TreeView()
        dlg.vbox.pack_start(driver_list, True)

        store = gtk.ListStore(str)

        text_renderer = gtk.CellRendererText()

        column = gtk.TreeViewColumn("Name", text_renderer, text=0)
        driver_list.append_column(column)

        drivers = jack.get_available_driver()
        for driver in drivers:
            store.append([driver])

        driver_list.set_model(store)

        selection = driver_list.get_selection()

        current_driver = jack.get_selected_driver()
        if current_driver:
            for row in store:
                if current_driver == row[0]:
                    selection.select_iter(row.iter)

        driver_list.connect("row-activated", lambda *x: dlg.response(gtk.RESPONSE_OK))

        driver = None

        dlg.show_all()
        ret = dlg.run()
        if ret == gtk.RESPONSE_OK:
            jack.select_driver(store.get(selection.get_selected()[1], 0)[0])
        dlg.hide()

class parameter_enum_value(gobject.GObject):
    def __init__(self, is_fake_value, value, description):
        gobject.GObject.__init__(self)
        self.is_fake_value = is_fake_value
        self.value = value
        self.description = description

    def get_description(self):
        if self.is_fake_value:
            return self.description

        return str(self.value) + " - " + self.description

gobject.type_register(parameter_enum_value)

class parameter_store(gobject.GObject):
    def __init__(self, param):
        gobject.GObject.__init__(self)
        self.param = param
        self.name = self.param.get_name()
        self.is_set, self.default_value, self.value = self.param.get_value()
        self.modified = False
        self.has_range = self.param.has_range()
        self.is_strict = self.param.is_strict_enum()
        self.is_fake_value = self.param.is_fake_values_enum()

        self.enum_values = []

        for enum_value in self.param.get_enum_values():
            self.enum_values.append(parameter_enum_value(self.is_fake_value, enum_value[0], enum_value[1]))

    def get_name(self):
        return self.name

    def get_type(self):
        return self.param.get_type()

    def get_value(self):
        return self.value

    def set_value(self, value):
        #print "%s -> %s" % (self.name, value)
        self.value = value
        self.modified = True

    def get_short_description(self):
        return self.param.get_short_description()

    def maybe_save_value(self):
        if self.modified:
            self.param.set_value(self.value)
            self.modified = False

    def has_range(self):
        return self.has_range

    def has_enum(self):
        return len(self.enum_values) != 0

    def is_strict_enum(self):
        return self.is_strict

    def get_enum_values(self):
        return self.enum_values

gobject.type_register(parameter_store)

def combobox_get_active_text(combobox, model_index = 0):
    model = combobox.get_model()
    active = combobox.get_active()
    if active < 0:
        return None
    return model[active][model_index]

class cell_renderer_param(gtk.GenericCellRenderer):
    __gproperties__ = { "parameter": (gobject.TYPE_OBJECT, "Parameter", "Parameter", gobject.PARAM_READWRITE) }

    def __init__(self):
        self.__gobject_init__()
        self.parameter = None
        #self.set_property('mode', gtk.CELL_RENDERER_MODE_EDITABLE)
        #self.set_property('mode', gtk.CELL_RENDERER_MODE_ACTIVATABLE)
        self.renderer_text = gtk.CellRendererText()
        self.renderer_toggle = gtk.CellRendererToggle()
        self.renderer_combo = gtk.CellRendererCombo()
        self.renderer_spinbutton = gtk.CellRendererSpin()
        self.renderer = None

    def do_set_property(self, pspec, value):
        if pspec.name == 'parameter':
            if value.get_type() == 'b':
                self.set_property('mode', gtk.CELL_RENDERER_MODE_ACTIVATABLE)
            else: 
                self.set_property('mode', gtk.CELL_RENDERER_MODE_EDITABLE)
        else:
            print pspec.name
        setattr(self, pspec.name, value)

    def do_get_property(self, pspec):
        return getattr(self, pspec.name)

    def choose_renderer(self):
        typechar = self.parameter.get_type()
        value = self.parameter.get_value()

        if typechar == "b":
            self.renderer = self.renderer_toggle
            self.renderer.set_property('activatable', True)
            self.renderer.set_property('active', value)
            self.renderer.set_property("xalign", 0.0)
            return

        # TODO: constraints
        if typechar == 'u' or typechar == 'i':
            self.renderer = self.renderer_spinbutton
            self.renderer.set_property('text', str(value))
            self.renderer.set_property('editable', True)
            self.renderer.set_property('adjustment', gtk.Adjustment(value, 0, 100000, 1, 1000))
            return

        if self.parameter.has_enum():
            self.renderer = self.renderer_combo

            m = gtk.ListStore(str, parameter_enum_value)

            for value in self.parameter.get_enum_values():
                m.append([value.get_description(), value])

            self.renderer.set_property("model",m)
            self.renderer.set_property('text-column', 0)
            self.renderer.set_property('editable', True)
            self.renderer.set_property('has_entry', not self.parameter.is_strict_enum())

            value = self.parameter.get_value()
            if self.parameter.is_fake_value:
                text = "???"
                for enum_value in self.parameter.get_enum_values():
                    if enum_value.value == value:
                        text = enum_value.get_description()
                        break
            else:
                text = str(value)

            self.renderer.set_property('text', text)

            return

        self.renderer = self.renderer_text
        self.renderer.set_property('editable', True)
        self.renderer.set_property('text', self.parameter.get_value())

    def on_render(self, window, widget, background_area, cell_area, expose_area, flags):
        self.choose_renderer()
        return self.renderer.render(window, widget, background_area, cell_area, expose_area, flags)

    def on_get_size(self, widget, cell_area=None):
        self.choose_renderer()
        return self.renderer.get_size(widget, cell_area)

    def on_activate(self, event, widget, path, background_area, cell_area, flags):
        self.choose_renderer()
        if self.parameter.get_type() == 'b':
            self.parameter.set_value(not self.parameter.get_value())
        return True

    def on_editing_done(self, widget, parameter):
        typechar = parameter.get_type()
        if type(widget) == gtk.ComboBox:
            value_str = combobox_get_active_text(widget, 1).value
        elif type(widget) == gtk.ComboBoxEntry:
            enum_value = combobox_get_active_text(widget, 1)
            if enum_value:
                value_str = enum_value.value
            else:
                value_str = widget.get_active_text()
        else:
            value_str = widget.get_property('text')

        if typechar == 'u' or typechar == 'i':
            value = int(value_str)
        else:
            value = value_str
        parameter.set_value(value)

    def on_start_editing(self, event, widget, path, background_area, cell_area, flags):
        # start_editing throws exception if event is not GdkEvent. Happens when editing is initiated using keyboard.
        # FIXME: make editing initiated using keyboard work
        if not event:
            return None

        self.choose_renderer()
        ret = self.renderer.start_editing(event, widget, path, background_area, cell_area, flags)
        if ret:
            ret.connect("editing-done", self.on_editing_done, self.parameter)
        return ret

gobject.type_register(cell_renderer_param)

class jack_params_configure_command(configure_command):
    def __init__(self, proxy):
        self.proxy = proxy

    def run(self, arg):
        dlg = gtk.Dialog()
        dlg.set_title(self.get_window_title())
        dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
        dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK)

        #dlg.set_transient_for(window)

        self.liststore = gtk.ListStore(str, parameter_store, str)
        self.treeview = gtk.TreeView(self.liststore)
        self.treeview.set_rules_hint(True)

        renderer_text = gtk.CellRendererText()
        renderer_value = cell_renderer_param()

        self.tvcolumn_parameter = gtk.TreeViewColumn('Parameter', renderer_text, text=0)
        self.tvcolumn_value = gtk.TreeViewColumn('Value', renderer_value, parameter=1)
        self.tvcolumn_description = gtk.TreeViewColumn('Description', renderer_text, text=2)

        self.tvcolumn_value.set_resizable(True)
        self.tvcolumn_value.set_min_width(100)

        self.treeview.append_column(self.tvcolumn_parameter)
        self.treeview.append_column(self.tvcolumn_value)
        self.treeview.append_column(self.tvcolumn_description)

        dlg.vbox.pack_start(self.treeview, True)

        self.params = self.proxy()

        for param in self.params:
            self.liststore.append([param.get_name(), parameter_store(param), param.get_short_description()])

        dlg.show_all()
        ret = dlg.run()
        if ret == gtk.RESPONSE_OK:
            for row in self.liststore:
                param = row[1]
                if param.modified:
                    #print "%s -> %s" % (param.get_name(), param.get_value())
                    param.maybe_save_value()
        dlg.hide()

class jack_engine_params_configure_command(jack_params_configure_command):
    def __init__(self):
        jack_params_configure_command.__init__(self, engine_parameters_proxy)

    def get_description(self):
        return 'JACK engine parameters'

class jack_driver_params_configure_command(jack_params_configure_command):
    def __init__(self):
        jack_params_configure_command.__init__(self, driver_parameters_proxy)

    def get_description(self):
        return 'JACK driver parameters'

    def get_window_title(self):
        return 'JACK "%s" driver parameters' % jack.get_selected_driver()

commands = [
    jack_driver_change_command(),
    jack_engine_params_configure_command(),
    jack_driver_params_configure_command(),
    ]

window = gtk.Window()

buttons_widget = gtk.VBox()

for command in commands:
    button = gtk.Button(command.get_description())
    button.connect('released', command.run)
    buttons_widget.pack_start(button)

window.add(buttons_widget)

window.show_all()
window.connect('destroy', gtk.main_quit)

gtk.main()
